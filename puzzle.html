<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Number‑Snake Workshop</title>
<style>
  :root{--cell:64;--dot:20}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:1rem;display:flex;gap:1.5rem}
  #board{background:#fff;box-shadow:0 0 0 4px #000;cursor:pointer}
  #side{min-width:260px;display:flex;flex-direction:column}
  .tabs{display:flex;border-bottom:2px solid #000;margin-bottom:1rem}
  .tab-btn{flex:1;padding:0.5rem 0;text-align:center;border:1px solid #000;border-bottom:none;cursor:pointer;font-weight:600;background:#eaeaea}
  .tab-btn.active{background:#fff}
  .tab-content{display:none;flex-direction:column;gap:1rem}
  .tab-content.active{display:flex}
  button{padding:0.45rem 0.9rem;border:1px solid #000;border-radius:4px;background:#f0f0f0;cursor:pointer;font-weight:600}
  button:disabled{opacity:.5;cursor:not-allowed}
  #status,#buildStatus{font-weight:600;min-height:1.2rem}
</style>
</head>
<body>
  <canvas id="board" width="448" height="448"></canvas>
  <div id="side">
    <div class="tabs">
      <div class="tab-btn active" data-tab="solveTab">Solve</div>
      <div class="tab-btn" data-tab="buildTab">Build</div>
    </div>
    <!-- Solve UI -->
    <div id="solveTab" class="tab-content active">
      <label><input type="checkbox" id="animateChk"> Animate full search</label>
      <button id="startBtn">Start</button>
      <div id="status">idle</div>
    </div>
    <!-- Build UI -->
    <div id="buildTab" class="tab-content">
      <button id="clearBtn">Clear</button>
      <div id="buildStatus">build mode ready</div>
    </div>
  </div>
<script>
/************* GLOBAL DATA (starts with example) *************/
const N=7, CELL=64, R=20;
let dots = {1:[3,3],2:[6,6],3:[5,1],4:[3,5],5:[0,0],6:[1,5],7:[3,1]};
let walls= new Set(['1,5|2,5','2,5|3,5','2,3|3,3','3,3|4,3','3,1|4,1','4,1|5,1']);
/************************************************************/
const cvs=document.getElementById('board'); const ctx=cvs.getContext('2d'); ctx.lineCap='round';
const dirs=[[ -1,0],[1,0],[0,-1],[0,1]];
const id=(r,c)=>r*N+c;
const edgeKey=(r1,c1,r2,c2)=>`${r1},${c1}|${r2},${c2}`;
const hasEdge=(r1,c1,r2,c2)=>walls.has(edgeKey(r1,c1,r2,c2))||walls.has(edgeKey(r2,c2,r1,c1));

/********************** DRAW *************************/
function drawBoard(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  // grid
  ctx.strokeStyle='#c0c0c0'; ctx.lineWidth=1.5;
  for(let i=0;i<=N;i++){ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,N*CELL);ctx.stroke();ctx.beginPath();ctx.moveTo(0,i*CELL);ctx.lineTo(N*CELL,i*CELL);ctx.stroke();}
  // walls
  ctx.strokeStyle='#000'; ctx.lineWidth=6;
  walls.forEach(e=>{const[[r1,c1],[r2,c2]]=e.split('|').map(s=>s.split(',').map(Number)); if(r1===r2){const x=Math.max(c1,c2)*CELL;ctx.beginPath();ctx.moveTo(x,r1*CELL);ctx.lineTo(x,(r1+1)*CELL);ctx.stroke();}else{const y=Math.max(r1,r2)*CELL;ctx.beginPath();ctx.moveTo(c1*CELL,y);ctx.lineTo((c1+1)*CELL,y);ctx.stroke();}});
  // dots
  for(const[num,[r,c]] of Object.entries(dots)){ctx.fillStyle='#000';ctx.beginPath();ctx.arc(c*CELL+CELL/2,r*CELL+CELL/2,R,0,Math.PI*2);ctx.fill();ctx.fillStyle='#fff';ctx.font='16px sans-serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(num,c*CELL+CELL/2,r*CELL+CELL/2);} }
function drawPath(p,col='#ff8800'){if(p.length<2)return;ctx.strokeStyle=col;ctx.lineWidth=4;ctx.beginPath();ctx.moveTo(p[0][1]*CELL+CELL/2,p[0][0]*CELL+CELL/2);for(let i=1;i<p.length;i++){const[r,c]=p[i];ctx.lineTo(c*CELL+CELL/2,r*CELL+CELL/2);}ctx.stroke();}

/********************** SOLVER *************************/
function targetSeq(){return Object.keys(dots).map(Number).sort((a,b)=>a-b).slice(1);}   // after 1
function fastSolve(){ if(!dots[1]) return null; const total=N*N; const vis=new Uint8Array(total); const stack=[]; const path=[]; const targets=targetSeq(); const last=Math.max(...Object.keys(dots).map(Number)); stack.push({r:dots[1][0],c:dots[1][1],idx:0,stage:0}); while(stack.length){const n=stack.pop();const key=id(n.r,n.c); if(n.stage===0){ if(vis[key])continue; vis[key]=1; path.push([n.r,n.c]); let tidx=n.idx; if(tidx<targets.length){const[tr,tc]=dots[targets[tidx]]; if(n.r===tr&&n.c===tc) tidx++; else if(Object.entries(dots).some(([num,[dr,dc]])=>+num!==1&&+num!==targets[tidx]&&dr===n.r&&dc===n.c)){vis[key]=0;path.pop();continue;}} if(path.length===total && tidx===targets.length && n.r===dots[last][0]&&n.c===dots[last][1]) return path; stack.push({r:n.r,c:n.c,idx:tidx,stage:1}); for(const[dr,dc] of dirs){const nr=n.r+dr,nc=n.c+dc; if(nr<0||nr>=N||nc<0||nc>=N)continue; if(hasEdge(n.r,n.c,nr,nc)||vis[id(nr,nc)])continue; stack.push({r:nr,c:nc,idx:tidx,stage:0});}} else {vis[key]=0; path.pop();}} return null; }

/********************** BUILD ACTIONS *************************/
const buildStatus=document.getElementById('buildStatus');
function highestDot(){return Math.max(0,...Object.keys(dots).map(Number));}
function toggleWall(r1,c1,r2,c2){const k=edgeKey(r1,c1,r2,c2); const rev=edgeKey(r2,c2,r1,c1); if(walls.delete(k)||walls.delete(rev)) return; walls.add(k); }

cvs.addEventListener('click',e=>{
  if(!document.querySelector('[data-tab="buildTab"]').classList.contains('active')) return;
  const rect=cvs.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const c=Math.floor(x/CELL), r=Math.floor(y/CELL); if(r<0||r>=N||c<0||c>=N) return;
  const gx=x%CELL, gy=y%CELL, tol=6;
  const left=gx<tol, right=CELL-gx<tol, top=gy<tol, bottom=CELL-gy<tol;
  if(left&&c>0){toggleWall(r,c-1,r,c);buildStatus.textContent='toggled wall';drawBoard();return;}
  if(right&&c<N-1){toggleWall(r,c,r,c+1);buildStatus.textContent='toggled wall';drawBoard();return;}
  if(top&&r>0){toggleWall(r-1,c,r,c);buildStatus.textContent='toggled wall';drawBoard();return;}
  if(bottom&&r<N-1){toggleWall(r,c,r+1,c);buildStatus.textContent='toggled wall';drawBoard();return;}
  // nodes
  let numClicked=null; for(const[num,[dr,dc]] of Object.entries(dots)) if(dr===r&&dc===c){numClicked=+num;break;}
  if(numClicked){const hi=highestDot(); if(numClicked===hi){delete dots[numClicked];buildStatus.textContent=`Deleted node ${numClicked}`;} else {buildStatus.textContent='⚠️ Delete highest node first';} drawBoard();return;}
  const next=highestDot()+1; dots[next]=[r,c]; buildStatus.textContent=`Added node ${next}`; drawBoard();
});

/********************** UI: Tabs, Clear, Solve *************************/
document.querySelectorAll('.tab-btn').forEach(btn=>btn.addEventListener('click',()=>{document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));document.querySelectorAll('.tab-content').forEach(p=>p.classList.remove('active'));btn.classList.add('active');document.getElementById(btn.dataset.tab).classList.add('active');drawBoard();}));

document.getElementById('clearBtn').addEventListener('click',()=>{dots={};walls=new Set();buildStatus.textContent='cleared — add nodes & walls';drawBoard();});

const startBtn=document.getElementById('startBtn'); const statusEl=document.getElementById('status');
startBtn.addEventListener('click',()=>{statusEl.textContent='searching…';startBtn.disabled=true;requestAnimationFrame(()=>{drawBoard(); setTimeout(()=>{const sol=fastSolve(); if(sol){drawPath(sol); statusEl.textContent='✅ solved';} else {statusEl.textContent='❌ no path';} startBtn.disabled=false;},0);});});

/********************** INIT *************************/
drawBoard();
</script>
</body>
</html>