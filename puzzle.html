<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Number‑Snake — live search visualiser</title>
  <style>
    :root{--cell:64;--dot:20}
    body{display:flex;justify-content:center;margin:1rem;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    canvas{background:#fff;box-shadow:0 0 0 4px #000}
    #status{position:fixed;bottom:12px;left:12px;font-weight:600}
  </style>
</head>
<body>
  <canvas id="board" width="448" height="448"></canvas>
  <div id="status">loading…</div>

<script>
/********************  CONFIG  ********************/
const N    = 7;                         // 7×7 grid
const CELL = 64;                        // px
const R    = 20;                        // dot radius

const dots = {                          // numbered circles
  1:[3,3], 2:[6,6], 3:[5,1], 4:[3,5], 5:[0,0], 6:[1,5], 7:[3,1]
};
const targetOrder = [2,3,4,5,6,7];

// bars that block vertical movement (pairs of adjacent cells)
const walls = new Set([
  '1,5|2,5','2,5|3,5',   // under 6 → 4
  '2,3|3,3','3,3|4,3',   // around 1
  '3,1|4,1','4,1|5,1'    // under 7 → 3
]);
/*************************************************/
const id=(r,c)=>r*N+c;
const dirs=[[ -1,0],[ 1,0],[ 0,-1],[ 0,1]]; // U D L R
const edge=(r1,c1,r2,c2)=>walls.has(`${r1},${c1}|${r2},${c2}`)||walls.has(`${r2},${c2}|${r1},${c1}`);
const sleep=ms=>new Promise(res=>setTimeout(res,ms));

/* canvas helpers */
const cvs=document.getElementById('board');
const ctx=cvs.getContext('2d');
ctx.lineCap='round';
const statusEl=document.getElementById('status');

function drawBoard(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  // grid
  ctx.strokeStyle='#c0c0c0';ctx.lineWidth=1.5;
  for(let i=0;i<=N;i++){
    ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,N*CELL);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,i*CELL);ctx.lineTo(N*CELL,i*CELL);ctx.stroke();
  }
  // bars
  ctx.strokeStyle='#000';ctx.lineWidth=6;
  walls.forEach(e=>{
    const [[r1,c1],[r2,c2]]=e.split('|').map(s=>s.split(',').map(Number));
    const y=Math.max(r1,r2)*CELL;
    ctx.beginPath();ctx.moveTo(c1*CELL,y);ctx.lineTo((c1+1)*CELL,y);ctx.stroke();
  });
  // dots
  for(const [num,[r,c]] of Object.entries(dots)){
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(c*CELL+CELL/2,r*CELL+CELL/2,R,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='16px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(num,c*CELL+CELL/2,r*CELL+CELL/2);
  }
}

function drawPath(path,color='#f80',alpha=1){
  if(path.length<2) return;
  ctx.strokeStyle=color; ctx.globalAlpha=alpha; ctx.lineWidth=4; ctx.beginPath();
  const [r0,c0]=path[0]; ctx.moveTo(c0*CELL+CELL/2,r0*CELL+CELL/2);
  for(let i=1;i<path.length;i++){
    const [r,c]=path[i]; ctx.lineTo(c*CELL+CELL/2,r*CELL+CELL/2);
  }
  ctx.stroke(); ctx.globalAlpha=1;
}

/********  depth‑first search with live painting  ********/
async function solveAndShow(){
  const total=N*N;
  const visited=new Uint8Array(total);
  const path=[];

  async function dfs(r,c,nextIdx){
    visited[id(r,c)]=1; path.push([r,c]);
    drawBoard(); drawPath(path,'#ffa500',0.6);   // draw exploration path in light orange
    await sleep(30);

    if(path.length===total && nextIdx===targetOrder.length && r===dots[7][0] && c===dots[7][1]){
      // found solution – over‑draw it in solid orange
      drawBoard(); drawPath(path,'#ff8800',1);
      statusEl.textContent='✅ solved';
      return true;
    }

    for(const [dr,dc] of dirs){
      const nr=r+dr,nc=c+dc;
      if(nr<0||nr>=N||nc<0||nc>=N) continue;
      if(edge(r,c,nr,nc))          continue;
      if(visited[id(nr,nc)])       continue;

      // dot ordering rules
      let idx=nextIdx;
      if(idx<targetOrder.length){
        const [tr,tc]=dots[targetOrder[idx]];
        if(nr===tr && nc===tc) idx++;
        else if(Object.values(dots).some(([dr2,dc2])=>dr2===nr&&dc2===nc)) continue; // wrong dot
      }
      if(await dfs(nr,nc,idx)) return true;
    }

    path.pop(); drawBoard(); drawPath(path,'#ffa500',0.6); await sleep(20);
    visited[id(r,c)]=0;
    return false;
  }

  statusEl.textContent='searching…';
  await dfs(dots[1][0],dots[1][1],0);
}

/* kick‑off */
(async ()=>{ drawBoard(); await solveAndShow(); })();
</script>
</body>
</html>
